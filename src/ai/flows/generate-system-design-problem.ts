'use server';
/**
 * @fileOverview Generates a system design problem with a solution, reasoning, key concepts, diagram description, diagram image, problem type, scale estimates, and capacity planning.
 *
 * - generateSystemDesignProblem - A function that generates a system design problem.
 * - GenerateSystemDesignProblemInput - The input type for the generateSystemDesignProblem function.
 * - GenerateSystemDesignProblemOutput - The return type for the generateSystemDesignProblem function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'zod';
import { supportedModels } from '@/lib/models';
import { sanitizeMermaidCode, validateMermaidSyntax } from '@/lib/mermaid-utils';

const GenerateSystemDesignProblemInputSchema = z.object({
  difficultyLevel: z
    .enum(['Easy', 'Medium', 'Hard'])
    .describe('The difficulty level of the system design problem.'),
  problemType: z
    .string()
    .optional()
    .describe('The type of system design problem to generate. If empty or not provided, a problem type will be generated by the AI.'),
  modelName: z.enum(supportedModels) // Use the enum of supported models
    .describe('The Gemini model to use for text generation.'),
});
export type GenerateSystemDesignProblemInput = z.infer<
  typeof GenerateSystemDesignProblemInputSchema
>;

const GenerateSystemDesignProblemOutputSchema = z.object({
  problemStatement: z.string().describe('The generated system design problem statement.'),
  scaleEstimates: z.string().describe('The scale estimates for the system (e.g., DAU, QPS, storage requirements), in Markdown format.'),
  solution: z.string().describe('The proposed solution to the system design problem, in detailed Markdown format. Include explanations for each component and their interactions.'),
  capacityPlanning: z.string().describe('Detailed capacity planning for each component in the solution based on the scale estimates, in Markdown format. This should cover how many resources (servers, database capacity, etc.) are needed.'),
  reasoning: z.string().describe('The reasoning behind the proposed solution, in detailed Markdown format. Explain the trade-offs and design choices made.'),
  keyConcepts: z.string().describe('The key concepts covered by the problem, as a comma-separated string.'),
  mermaidDiagram: z.string().describe('A valid Mermaid diagram (flowchart, graph, or C4 diagram) representing the system architecture. Must be syntactically correct Mermaid code that can be rendered directly. Use graph TD or flowchart TD for system design diagrams.'),
  generatedProblemType: z.string().describe('The specific type of problem that was generated or used by the AI.'),
});
export type GenerateSystemDesignProblemOutput = z.infer<
  typeof GenerateSystemDesignProblemOutputSchema
>;

export async function generateSystemDesignProblem(
  input: GenerateSystemDesignProblemInput
): Promise<GenerateSystemDesignProblemOutput> {
  return generateSystemDesignProblemFlow(input);
}

// Define the prompt outside the flow to potentially reuse it if needed,
// but the model will be determined by the flow's input.
const generateSystemDesignProblemPrompt = ai.definePrompt({
  name: 'generateSystemDesignProblemPrompt',
  input: {schema: GenerateSystemDesignProblemInputSchema},
  output: {schema: GenerateSystemDesignProblemOutputSchema}, // Mermaid is generated inline, no separate image step
  // Prompt text remains the same, Handlebars context accesses input fields directly
  prompt: `You are an expert system design problem generator.
Your goal is to populate a JSON object with the following fields: "problemStatement", "scaleEstimates", "solution", "capacityPlanning", "reasoning", "keyConcepts", "mermaidDiagram", and "generatedProblemType".

Inputs:
- Difficulty Level: {{{difficultyLevel}}}
{{#if problemType}}
- User-specified Problem Type: {{{problemType}}}
{{else}}
- User-specified Problem Type: (Not provided, please generate one)
{{/if}}

Instructions:

1.  **Determine the \`generatedProblemType\`**:
    {{#if problemType}}
    Use the user-specified problem type: "{{{problemType}}}".
    {{else}}
    Based on the "{{{difficultyLevel}}}" difficulty level, invent a specific and engaging system design problem type.
    Examples of problem types:
        - For Easy: "Design a basic URL shortener", "Design a simple hit counter for a webpage".
        - For Medium: "Design a real-time notification system for a social media app", "Design a scalable photo storage service".
        - For Hard: "Design a distributed logging system for a large-scale application", "Design a global video streaming service".
    Set the \`generatedProblemType\` field in your JSON output to this problem type (either user-specified or invented).
    {{/if}}

2.  **Generate Content for Other JSON Fields**:
    Using the determined \`generatedProblemType\` and the "{{{difficultyLevel}}}" difficulty level, generate content for the following fields:
    -   \`problemStatement\`: A clear and concise statement of the system to be designed.
    -   \`scaleEstimates\`: Provide realistic scale estimates for the system. **This must be in detailed Markdown format**. Include metrics like Daily Active Users (DAU), Queries Per Second (QPS) for reads and writes, data storage requirements (e.g., TB/year), data ingestion rate (e.g., GB/hour), and peak network bandwidth. The scale should be appropriate for the "{{{difficultyLevel}}}". For example, an "Easy" problem might have 10k DAU and 100 QPS, while a "Hard" problem might have 100M DAU and 1M QPS.
    -   \`solution\`: A high-level proposed solution. **This must be in detailed Markdown format**, explaining each component (e.g., Load Balancers, Web Servers, Application Servers, Databases (SQL/NoSQL), Caches, Message Queues, CDNs, Object Storage, Monitoring/Alerting), their interactions, and how they address the problem requirements. Provide thorough explanations and considerations for scalability, reliability, and performance.
    -   \`capacityPlanning\`: Detailed capacity planning based on the \`scaleEstimates\`. **This must be in detailed Markdown format**. For each major component in your \`solution\`, estimate the required resources. For example:
        *   Number of web/app server instances (e.g., "Given 1M QPS and assuming each server handles 10k QPS, we need 100 servers + 20% buffer = 120 servers").
        *   Database capacity and throughput (e.g., "For 10TB initial storage growing at 5TB/year, and 50k read QPS / 5k write QPS, we might need a sharded cluster of X nodes with Y specs").
        *   Cache size (e.g., "To cache 20% of the hot dataset of 1TB, we need 200GB of cache memory").
        *   Bandwidth requirements for CDN and storage.
        Explain your calculations and assumptions clearly.
    -   \`reasoning\`: The rationale behind the key design choices in your solution. **This must be in detailed Markdown format**, explaining trade-offs considered (e.g., consistency vs. availability, latency vs. cost), why specific technologies or patterns were chosen over alternatives, and potential bottlenecks or limitations.
    -   \`keyConcepts\`: A comma-separated string of important system design concepts relevant to this problem and solution (e.g., Load Balancing, Caching, Database Sharding, CAP Theorem, Microservices, Message Queues, Data Replication, Idempotency, Rate Limiting, Circuit Breaker).
    -   \`mermaidDiagram\`: A valid Mermaid diagram in \`graph TD\` or \`flowchart TD\` syntax that visually represents the proposed system architecture. The diagram MUST be syntactically correct Mermaid code. Rules:
        *   Use \`graph TD\` or \`flowchart TD\` as the diagram type.
        *   Use descriptive node IDs (e.g., \`LB[Load Balancer]\`, \`DB[(Database)]\`, \`Cache[Redis Cache]\`).
        *   Use standard Mermaid shapes: \`[rectangles]\` for services/servers, \`[(cylinders)]\` for databases, \`{diamonds}\` for decisions, \`([rounded])\` for users/clients.
        *   Show data flow with arrows: \`-->\`, \`-->|label|\`, \`-.->|async|\`.
        *   Group related components using \`subgraph\` blocks.
        *   Label all connections to show what data flows between components.
        *   **CRITICAL**: If any node label or edge label contains special characters like parentheses \`()\`, slashes \`/\`, ampersands \`&\`, angle brackets \`<>\`, or curly braces \`{}\`, you MUST wrap the label text in double quotes. Examples:
            - \`A["Service (HTTP/gRPC)"]\` NOT \`A[Service (HTTP/gRPC)]\`
            - \`-->|"Read/Write (async)"|\` NOT \`-->|Read/Write (async)|\`
            - \`DB["PostgreSQL (Primary)"]\` NOT \`DB[PostgreSQL (Primary)]\`
        *   Do NOT wrap the code in markdown code fences (no \`\`\`mermaid). Just output the raw Mermaid syntax.
        *   Example:
            graph TD
              Client([Client]) -->|HTTP Request| LB[Load Balancer]
              LB --> AS1[App Server 1]
              LB --> AS2[App Server 2]
              AS1 --> Cache[Redis Cache]
              AS1 --> DB[(PostgreSQL)]
              AS2 --> Cache
              AS2 --> DB

Ensure your output is a valid JSON object matching the schema.
`,
});

// AI prompt to fix broken Mermaid syntax
const fixMermaidPrompt = ai.definePrompt({
  name: 'fixMermaidPrompt',
  input: {schema: z.object({ mermaidCode: z.string(), errorMessage: z.string() })},
  output: {schema: z.object({ fixedMermaidCode: z.string() })},
  prompt: `You are a Mermaid diagram syntax expert. The following Mermaid code has a syntax error. Fix it and return ONLY the corrected Mermaid code.

Common issues to fix:
- Unquoted labels containing special characters like (), /, &, <>, {} must be wrapped in double quotes
  - BAD:  A[Service (HTTP/gRPC)] --> B
  - GOOD: A["Service (HTTP/gRPC)"] --> B
  - BAD:  A -->|Read/Write (async)| B
  - GOOD: A -->|"Read/Write (async)"| B
- Ensure all node IDs are valid (alphanumeric, no spaces)
- Ensure arrows are properly formatted (-->, -.->)
- Ensure subgraph blocks are properly closed with 'end'

Mermaid code with error:
\`\`\`
{{{mermaidCode}}}
\`\`\`

Error message: {{{errorMessage}}}

Return the fixed Mermaid code. Do NOT include markdown code fences in your output. Just the raw Mermaid syntax.`,
});


const generateSystemDesignProblemFlow = ai.defineFlow(
  {
    name: 'generateSystemDesignProblemFlow',
    inputSchema: GenerateSystemDesignProblemInputSchema,
    outputSchema: GenerateSystemDesignProblemOutputSchema,
  },
  async input => {
    // Call the prompt, passing the modelName from the input
    const {output: mainContentOutput} = await generateSystemDesignProblemPrompt(
        input, // Pass the full input object
        { model: input.modelName } // Specify the model dynamically
    );

    if (!mainContentOutput) {
      throw new Error('Failed to generate main content for the system design problem.');
    }

    // Sanitize the Mermaid diagram (regex-based, handles common issues)
    let mermaidDiagram = sanitizeMermaidCode(mainContentOutput.mermaidDiagram);

    // AI validation loop: attempt to parse, if it fails ask AI to fix (max 2 retries)
    const MAX_FIX_ATTEMPTS = 2;
    for (let attempt = 0; attempt < MAX_FIX_ATTEMPTS; attempt++) {
      const validationError = validateMermaidSyntax(mermaidDiagram);
      if (!validationError) break; // Syntax looks valid

      console.warn(`Mermaid validation issue (attempt ${attempt + 1}/${MAX_FIX_ATTEMPTS}):`, validationError);
      try {
        const { output: fixedOutput } = await fixMermaidPrompt(
          { mermaidCode: mermaidDiagram, errorMessage: validationError },
          { model: input.modelName }
        );
        if (fixedOutput?.fixedMermaidCode) {
          mermaidDiagram = sanitizeMermaidCode(fixedOutput.fixedMermaidCode);
        }
      } catch (fixError) {
        console.error('AI Mermaid fix failed:', fixError);
        break; // Don't retry if the fix prompt itself fails
      }
    }

    return {
      ...mainContentOutput,
      mermaidDiagram,
    };
  }
);
